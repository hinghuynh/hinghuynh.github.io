---
layout: post
title: Recursion
date: May 23, 2014
category: code
comments: true
customid: week8technicalblog
---
Recursion is the idea that a recursive method will continue to call itself until it is given explicit directions to stop with a conditional statement.  For me personally, I never saw the point of using recursion and avoided implementing it, because it was much more difficult to visualize conceptually over just an ordinary while or until loop that could pretty much do anything the recursion could do. Recursions also seem inefficient in the amount of computer resources needed to return a result.  So are there any benefits of using recursion or is just another way to do something that’s looks slightly more elegant and forces you to workout your programmer thinking muscles?After doing some reading on recursion, I’ve come to the conclusion that it’s just a different approach to solving a problem. Recursion has its performance and design tradeoffs. Sometimes it will give you a more elegant solution, but for the most part recursion will either produce a solution at about the same speed as a loop or be significantly slower.  So I’m going to show you an example of a challenge that I did this week Dev Bootcamp.  The challenge asked me to create a method in Ruby that checks if a number is number in Fibonacci sequence. By definition, the first two numbers in the Fibonacci sequence are 1 and 1, or 0 and 1, depending on the chosen starting point of the sequence, and each subsequent number is the sum of the previous two.Here was my original solution after refactoring with a normal while loop.![alt tag](/unit3_projects/images/recursion1.png?raw=true)This was my solution after converting into one that used recursion.![alt tag](/unit3_projects/images/recursion2.png?raw=true)After a little more refactoring I was able to get this one liner solution with recursion.![alt tag](/unit3_projects/images/recursion3.png?raw=true)After running my driver tests on all three solutions, I pretty much got the same speeds for all three solutions.  However, I must admit that my refactor recursion method looks particularly elegant, at least to me.  What are you guys’ thoughts?